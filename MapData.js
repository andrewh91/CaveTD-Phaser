
export default class MapData
{
    constructor()
    {
        this.tiles=[];
        this.terrainColours=[];     
        //also create colours associated with those terrains
        this.terrainColours[pathTerrain]=0xcccccc;//light grey
        this.terrainColours[rubbleTerrain]=0x777777;//medium grey
        this.terrainColours[wallTerrain]=0x333333;//dark grey
        this.terrainColours[wallTerrain+1]=0x000000;//black
    }
    getIndexFromCoords(v)
    {
        return v.x+v.y*mapWidth;
    }
    setTerrain(v,t)
    {
        //this can be out of bounds
        if(v.x>=0&&v.x<mapWidth && v.y>=0 && v.y <mapHeight)
        {
            //you can add more rubble to the wall to give it more 'health', but currently the colour will only go from light, medium and dark grey to black 
            this.tiles[this.getIndexFromCoords(v)].terrain = t;
            if(t>=this.terrainColours.length)
            {
                t=this.terrainColours.length-1;
            }
            this.tiles[this.getIndexFromCoords(v)].setTint(this.terrainColours[t]);
        }
        else
        {
            console.log('mapSetTerrain failed , x and y is out of bounds, x: ' + v.x + ' y: '+v.y)
        }
    }
    //when i build a map from a text file, i don't want to use the setTerrain method, as that requires a map coord, i just want to use the index
    setTerrainByIndex(a)
    {
        for(let i = 0 ; i < a.length ; i ++)
        {
            this.tiles[i].terrain=parseInt(a[i]);
            this.tiles[i].setTint(this.terrainColours[parseInt(a[i])]);
        }
    }
    //a wall is value 2 or higher, drilling a wall means reducing that value, if it reduces to 1 then it will become rubble
    drillWall(v)
    {
        let currentValue;
        //this can be out of bounds
        if(v.x>=0&&v.x<mapWidth && v.y>=0 && v.y <mapHeight)
        {
            currentValue = this.tiles[this.getIndexFromCoords(v)].terrain ;
            this.setTerrain(v,currentValue-1);
        }
        else
        {
            console.log('drillWall failed , x and y is out of bounds, x: ' + v.x + ' y: '+v.y)
        }
    }
    dumpRubble(v)
    {
        let currentValue;
        //this can be out of bounds
        if(v.x>=0&&v.x<mapWidth && v.y>=0 && v.y <mapHeight)
        {
            currentValue = this.tiles[this.getIndexFromCoords(v)].terrain ;
            this.setTerrain(v,currentValue+1);
        }
        else
        {
            console.log('dumpRubble failed , x and y is out of bounds, x: ' + v.x + ' y: '+v.y)
        }
    }
    setPlayer(v,index)
    {
        this.tiles[this.getIndexFromCoords(v)].playerIndex = index;
    }
    setVehicle(v,index)
    {
        this.tiles[this.getIndexFromCoords(v)].vehicleIndex = index;
    }
    getPlayerIndex(v)
    {
        return this.tiles[this.getIndexFromCoords(v)].playerIndex;
    }
    getVehicleIndex(v)
    {
        return this.tiles[this.getIndexFromCoords(v)].vehicleIndex;
    }
    isWall(v)
    {
        //path is 0, rubble is 1, a wall is 2 or more
        return this.tiles[this.getIndexFromCoords(v)].terrain>=wallTerrain;
    }
    isRubble(v)
    {
        //rubble is exactly 1
        return this.tiles[this.getIndexFromCoords(v)].terrain==rubbleTerrain;
    }
    isPath(v)
    {
        //path is exactly 0
        return this.tiles[this.getIndexFromCoords(v)].terrain==pathTerrain;
    }
    inBounds(v)
    {
        return (v.x>=0&&v.x<mapWidth  && v.y>=0&&v.y<mapHeight);
    }
    //this is just a helper method to display a text version of the map data
    //this uses 'dynamic property access' and 'bracket notation' to allow the user to specify a new variable of mapData.tiles to display, 
    //for example you can type in the debug console : 
    //window.debug.mapData.print("vehicleIndex");
    //add that will print the tiles.[i].vehicleIndex instead of the default playerIndex variable
    //so basically if you have v = {x:0,y:5}; you can access that like v.x or v.y but with this you could use v["x"] or v["y"]
    print(dataType = "terrain")
    {
        let text="";
        for(let i = 0; i < this.tiles.length ; i++)
        {
            let n = ("0" + this.tiles[i][dataType]).slice (-2);
            text+=n+',';
            if(i%mapWidth==mapWidth-1)
            {
                text+='\n';
            }
        }
        //remove the final 2 characters which is ',\n' note that '\n' counts as one character, so the comma and the line break are removed
        text=text.slice(0,-2);
        console.log(text);
        console.log("uses dynamic property access, try print('vehicleIndex'); or print('playerIndex');");
        return text;
    }
    //this method will take a text representation of map data, such as the one generated by mapData.print('terrain'); and use that to generate a map
    loadFromText(text)
    {
        let lineArray=[];
        //there will be a line break on the end of each line, split on that
        lineArray=text.split(',\n');
        //now we know the mapWidth 
        let loadedMapWidth = lineArray[0].length;
        let tileArray=[];
        for( let i = 0 ; i < lineArray.length ; i ++ )
        {
            //this will add each tile to the tileArray
            tileArray=tileArray.concat(lineArray[i].split(','));
        }
        console.log(tileArray);
        this.setTerrainByIndex(tileArray);
    }
}